# 🧠 KMP算法

# easy [344. Reverse String](https://leetcode.com/problems/reverse-string/)

## description

Write a function that reverses a string. The input string is given as an array of characters `s`.

You must do this by modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra memory. 

**Example 1:**

```
Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
```

**Example 2:**

```
Input: s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]
```

## solution

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        length = len(s)
        left = 0
        right = length - 1
        while left < right:
            tmp = s[left]
            s[left] = s[right]
            s[right] = tmp

            left += 1
            right -= 1

```

## thoughts

双指针

# easy [541. Reverse String II](https://leetcode.com/problems/reverse-string-ii/)

## description

Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string.

If there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original.

**Example 1:**

```
Input: s = "abcdefg", k = 2
Output: "bacdfeg"
```

**Example 2:**

```
Input: s = "abcd", k = 2
Output: "bacd"
```

## solution

```python
class Solution:
    def reverse1(self, s, left, right):
        while left < right:
            tmp = s[left]
            s[left] = s[right]
            s[right] = tmp
            left += 1
            right -= 1
        
    def reverseStr(self, s: str, k: int) -> str:
        s = list(s)

        length = len(s)

        for i in range(0, length, 2 * k):  # 每隔 2k 处理一块
            # 反转从 i 到 i + k（不一定够 k 个）
            left = i
            right = min(i + k - 1, len(s) - 1)
            # 在 [left, right] 之间原地反转
            self.reverse1(s, left, right)

        s = "".join(s)
        return s
```

## thoughts

**字符串是不可变的**，你可以读取某个字符，但不能直接修改它.如果你想修改字符串内容，就需要先 `list(s)` 转成字符列表，然后操作。

但是我好想写的很慢:

<img src="assets/image-20250625143847097.png" alt="image-20250625143847097" width="50%;" />

### 📄 代码分析

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        res = ''
        for i in range(0, len(s), 2*k):
            res += s[i: i + k][::-1] + s[i + k: i + 2 * k]
        return res
```

------

### 🔍 关键部分解释

#### `for i in range(0, len(s), 2*k)`：

- 每次处理一个 **`2k` 的块**
- `i` 是当前块的起始下标

------

#### `s[i: i + k][::-1]`

- 取出从 `i` 开始的前 `k` 个字符（可能不足 `k`）
- `[::-1]` 表示把这段字符**反转**
- ✅ 这就是题目要求的：**每 2k 个字符中，反转前 k 个**

------

#### `s[i + k: i + 2 * k]`

- 取出当前块中剩下的 k 个字符（如果有）
- ✅ 按题目要求，**这部分不反转**

# Med [151. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)

## description

Given an input string `s`, reverse the order of the **words**.

A **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.

Return *a string of the words in reverse order concatenated by a single space.*

**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

**Example 1:**

```
Input: s = "the sky is blue"
Output: "blue is sky the"
```

**Example 2:**

```
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
```

**Example 3:**

```
Input: s = "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
```

## solution

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        words = s.split()

        words.reverse()

        result = ' '.join(words)

        return result
```

## thoughts

?.感觉如果发现了s.split是列表就方便了

# easy [459. Repeated Substring Pattern](https://leetcode.com/problems/repeated-substring-pattern/)

## description

Given a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

**Example 1:**

```
Input: s = "abab"
Output: true
Explanation: It is the substring "ab" twice.
```

**Example 2:**

```
Input: s = "aba"
Output: false
```

**Example 3:**

```
Input: s = "abcabcabcabc"
Output: true
Explanation: It is the substring "abc" four times or the substring "abcabc" twice.
```

## solution

暴力解法:

```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:

        for i in range(0, len(s)//2):
            print(i)
            if len(s) % (i+1) == 0:
                sub = s[:(i+1)]
                print(sub)
                if sub * (len(s)//(i+1)) == s:
                    return True
        return False
```

简单解法:

```python
s in (s + s)[1:-1]
```

## thoughts



