# å‰æ

## å®Œå…¨äºŒå‰æ ‘

å®Œå…¨äºŒå‰æ ‘çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ h å±‚ï¼ˆhä»1å¼€å§‹ï¼‰ï¼Œåˆ™è¯¥å±‚åŒ…å« 1~ 2^(h-1) ä¸ªèŠ‚ç‚¹ã€‚

<img src="assets/68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303932303232313633383930332e706e67.png" alt="img" style="width:50%;" />

## äºŒå‰æœç´¢æ ‘

å‰é¢ä»‹ç»çš„æ ‘ï¼Œéƒ½æ²¡æœ‰æ•°å€¼çš„ï¼Œè€ŒäºŒå‰æœç´¢æ ‘æ˜¯æœ‰æ•°å€¼çš„äº†ï¼Œ**äºŒå‰æœç´¢æ ‘æ˜¯ä¸€ä¸ªæœ‰åºæ ‘**ã€‚

- è‹¥å®ƒçš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›
- è‹¥å®ƒçš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å¤§äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼›
- å®ƒçš„å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æ’åºæ ‘

ä¸‹é¢è¿™ä¸¤æ£µæ ‘éƒ½æ˜¯æœç´¢æ ‘

[<img src="assets/68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303830363139303330343639332e706e67.png" alt="img" style="width:50%;" />](https://camo.githubusercontent.com/8539fe8e5f70e95820fce7dc0abf9f1705b03fa19f3f152d881847952a1e9c1b/68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303830363139303330343639332e706e67)

## å¹³è¡¡äºŒå‰æœç´¢æ ‘

å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼šåˆè¢«ç§°ä¸ºAVLï¼ˆAdelson-Velsky and Landisï¼‰æ ‘ï¼Œä¸”å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼šå®ƒæ˜¯ä¸€æ£µç©ºæ ‘æˆ–å®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ï¼Œå¹¶ä¸”å·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘ã€‚

å¦‚å›¾ï¼š

[<img src="assets/68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303830363139303531313936372e706e67.png" alt="img" style="width:50%;" />](https://camo.githubusercontent.com/d55d08174281c5a4e6aa6ac13de38c7394c289bea3d5012d2c847cc096c5efea/68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303830363139303531313936372e706e67)

æœ€åä¸€æ£µ ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼Œå› ä¸ºå®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼è¶…è¿‡äº†1ã€‚

## éå†æ–¹å¼

- å‰åºéå†ï¼šä¸­å·¦å³
- ä¸­åºéå†ï¼šå·¦ä¸­å³
- ååºéå†ï¼šå·¦å³ä¸­

<img src="assets/68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303830363139313130393839362e706e67.png" alt="img" style="width:50%;" />

# é¢˜ç›®

## éå†

### easy 144 [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)

buyongé€’å½’

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack = [root]
        res = []
        while stack:
            node = stack.pop()
            print(node.val)
            res.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return res
```

### easy 145 [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)

no é€’å½’

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        stack = [root]
        res = []

        while stack:
            node = stack.pop()
            res.append(node.val)

            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
            
        return res[::-1]
```

### med 95[Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/)

å¯¹äºåŒºé—´ `[start, end]`ï¼Œå°è¯•æ¯ä¸ª `i` ä½œä¸ºæ ¹èŠ‚ç‚¹ï¼›

é€’å½’ç”Ÿæˆæ‰€æœ‰ `i` å·¦è¾¹çš„æ ‘ï¼ˆä½œä¸ºå·¦å­æ ‘ï¼‰ï¼›

é€’å½’ç”Ÿæˆæ‰€æœ‰ `i` å³è¾¹çš„æ ‘ï¼ˆä½œä¸ºå³å­æ ‘ï¼‰ï¼›

æ¯ä¸ª `å·¦å­æ ‘ Ã— å³å­æ ‘` çš„ç»„åˆï¼Œå’Œæ ¹èŠ‚ç‚¹ç»„åˆæˆä¸€æ£µæ ‘ã€‚

```python
class Solution:
    def generateTrees(self, n: int) -> List[Optional[TreeNode]]:
        
        def build(start, end):
            if start > end:
                return [None]
            
            trees = []
            for i in range(start, end + 1):
                left = build(start, i - 1)
                right = build(i + 1, end)
                for l in left:
                    for r in right:
                        trees.append(TreeNode(i, l, r))

            return trees

        return build(1, n)
```

### med 102 [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

**åˆå§‹åŒ–ä¸€ä¸ªé˜Ÿåˆ—**ï¼Œå°†æ ¹èŠ‚ç‚¹æ”¾å…¥ï¼›

**å¾ªç¯å¤„ç†é˜Ÿåˆ—**ç›´åˆ°ä¸ºç©ºï¼š

- å½“å‰å±‚æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹å°±å¤„ç†å¤šå°‘æ¬¡ï¼›
- ä¾æ¬¡å¼¹å‡ºè¿™äº›èŠ‚ç‚¹ï¼ŒåŠ å…¥ç»“æœï¼›
- å°†å®ƒä»¬çš„å·¦å³å­©å­ï¼ˆå¦‚æœæœ‰ï¼‰åŠ å…¥é˜Ÿåˆ—ï¼›

æœ€ç»ˆè¿”å›æŒ‰å±‚åˆ†ç»„çš„ç»“æœã€‚

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        res = []
        queue = deque([root])

        while queue:
            level_nodes = []
            level_size = len(queue)

            for _ in range(level_size):
                node = queue.popleft()
                level_nodes.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node .right:
                    queue.append(node.right)
            res.append(level_nodes)
                
        return res

```

## å±æ€§

### easy [101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)

è¦æ¯”è¾ƒä¸¤ä¸ªèŠ‚ç‚¹æ•°å€¼ç›¸ä¸ç›¸åŒï¼Œé¦–å…ˆè¦æŠŠä¸¤ä¸ªèŠ‚ç‚¹ä¸ºç©ºçš„æƒ…å†µå¼„æ¸…æ¥šï¼å¦åˆ™åé¢æ¯”è¾ƒæ•°å€¼çš„æ—¶å€™å°±ä¼šæ“ä½œç©ºæŒ‡é’ˆäº†ã€‚

èŠ‚ç‚¹ä¸ºç©ºçš„æƒ…å†µæœ‰ï¼šï¼ˆ**æ³¨æ„æˆ‘ä»¬æ¯”è¾ƒçš„å…¶å®ä¸æ˜¯å·¦å­©å­å’Œå³å­©å­ï¼Œæ‰€ä»¥å¦‚ä¸‹æˆ‘ç§°ä¹‹ä¸ºå·¦èŠ‚ç‚¹å³èŠ‚ç‚¹**ï¼‰

- å·¦èŠ‚ç‚¹ä¸ºç©ºï¼Œå³èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œä¸å¯¹ç§°ï¼Œreturn false
- å·¦ä¸ä¸ºç©ºï¼Œå³ä¸ºç©ºï¼Œä¸å¯¹ç§° return false
- å·¦å³éƒ½ä¸ºç©ºï¼Œå¯¹ç§°ï¼Œè¿”å›true

æ­¤æ—¶å·²ç»æ’é™¤æ‰äº†èŠ‚ç‚¹ä¸ºç©ºçš„æƒ…å†µï¼Œé‚£ä¹ˆå‰©ä¸‹çš„å°±æ˜¯å·¦å³èŠ‚ç‚¹ä¸ä¸ºç©ºï¼š

- å·¦å³éƒ½ä¸ä¸ºç©ºï¼Œæ¯”è¾ƒèŠ‚ç‚¹æ•°å€¼ï¼Œä¸ç›¸åŒå°±return false

æ­¤æ—¶æ‰è¿›å…¥å•å±‚é€’å½’çš„é€»è¾‘ï¼Œå•å±‚é€’å½’çš„é€»è¾‘å°±æ˜¯å¤„ç† å·¦å³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œä¸”æ•°å€¼ç›¸åŒçš„æƒ…å†µã€‚

- æ¯”è¾ƒäºŒå‰æ ‘å¤–ä¾§æ˜¯å¦å¯¹ç§°ï¼šä¼ å…¥çš„æ˜¯å·¦èŠ‚ç‚¹çš„å·¦å­©å­ï¼Œå³èŠ‚ç‚¹çš„å³å­©å­ã€‚
- æ¯”è¾ƒå†…ä¾§æ˜¯å¦å¯¹ç§°ï¼Œä¼ å…¥å·¦èŠ‚ç‚¹çš„å³å­©å­ï¼Œå³èŠ‚ç‚¹çš„å·¦å­©å­ã€‚
- å¦‚æœå·¦å³éƒ½å¯¹ç§°å°±è¿”å›true ï¼Œæœ‰ä¸€ä¾§ä¸å¯¹ç§°å°±è¿”å›false ã€‚

é€’å½’

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def Compare(self, left, right):
        
        if(left == None and right != None): return False
        if(left != None and right == None): return False
        if(left == None and right == None): return True
        print(left.val, right.val)
        if (left.val != right.val): return False

        outside = self.Compare(left.left, right.right)
        inside = self.Compare(left.right, right.left)
        issame = outside & inside
        return issame

    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        return self.Compare(root.left, root.right)
```

è¿­ä»£

è¿™ä¸ªè¿­ä»£æ³•ï¼Œå…¶å®æ˜¯æŠŠå·¦å³ä¸¤ä¸ªå­æ ‘è¦æ¯”è¾ƒçš„å…ƒç´ é¡ºåºæ”¾è¿›ä¸€ä¸ªå®¹å™¨ï¼Œç„¶åæˆå¯¹æˆå¯¹çš„å–å‡ºæ¥è¿›è¡Œæ¯”è¾ƒ

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:

    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        stack = []
        stack.append(root.right)
        stack.append(root.left)
        
        while stack:
            left = stack.pop()
            right = stack.pop()
            if left is None and right is None:
                continue
            if left is None or right is None:
                return False
            if left.val != right.val:
                return False

            stack.append(left.left)
            stack.append(right.right)
            stack.append(left.right)
            stack.append(right.left)
        return True
```



### 104 [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

æœ¬é¢˜å¯ä»¥ä½¿ç”¨å‰åºï¼ˆä¸­å·¦å³ï¼‰ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ååºéå†ï¼ˆå·¦å³ä¸­ï¼‰ï¼Œä½¿ç”¨å‰åºæ±‚çš„å°±æ˜¯æ·±åº¦ï¼Œä½¿ç”¨ååºæ±‚çš„æ˜¯é«˜åº¦ã€‚

- äºŒå‰æ ‘èŠ‚ç‚¹çš„æ·±åº¦ï¼šæŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°æˆ–è€…èŠ‚ç‚¹æ•°ï¼ˆå–å†³äºæ·±åº¦ä»0å¼€å§‹è¿˜æ˜¯ä»1å¼€å§‹ï¼‰
- äºŒå‰æ ‘èŠ‚ç‚¹çš„é«˜åº¦ï¼šæŒ‡ä»è¯¥èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°æˆ–è€…èŠ‚ç‚¹æ•°ï¼ˆå–å†³äºé«˜åº¦ä»0å¼€å§‹è¿˜æ˜¯ä»1å¼€å§‹ï¼‰

**è€Œæ ¹èŠ‚ç‚¹çš„é«˜åº¦å°±æ˜¯äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦**ï¼Œæ‰€ä»¥æœ¬é¢˜ä¸­æˆ‘ä»¬é€šè¿‡ååºæ±‚çš„æ ¹èŠ‚ç‚¹é«˜åº¦æ¥æ±‚çš„äºŒå‰æ ‘æœ€å¤§æ·±åº¦ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def godeep(self, node, count):
        if node == None:
            return count
        count += 1
        leftdeep = self.godeep(node.left, count)
        rightdeep = self.godeep(node.right, count)
        return max(leftdeep, rightdeep)

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None : return 0
        count = 0
        return self.godeep(root, count)
```

### 111 [Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)

å¦‚æœå·¦å­æ ‘ä¸ºç©ºï¼Œå³å­æ ‘ä¸ä¸ºç©ºï¼Œè¯´æ˜æœ€å°æ·±åº¦æ˜¯ 1 + å³å­æ ‘çš„æ·±åº¦ã€‚

åä¹‹ï¼Œå³å­æ ‘ä¸ºç©ºï¼Œå·¦å­æ ‘ä¸ä¸ºç©ºï¼Œæœ€å°æ·±åº¦æ˜¯ 1 + å·¦å­æ ‘çš„æ·±åº¦ã€‚

æœ€åå¦‚æœå·¦å³å­æ ‘éƒ½ä¸ä¸ºç©ºï¼Œè¿”å›å·¦å³å­æ ‘æ·±åº¦æœ€å°å€¼ + 1 

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def godeep(self, node, count):
        if not node.left and not node.right:
            return count

        if not node.left and node.right:
            return self.godeep(node.right, count+1)
        if not node.right and node.left:
            return self.godeep(node.left, count+1)
        
        left_depth = self.godeep(node.left, count + 1)
        right_depth = self.godeep(node.right, count + 1)

        return min(left_depth, right_depth)

    def minDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        count = 1
        return self.godeep(root, count)
        
```

### 222[Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/)

```python
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root: return 0
        
        count = 0
        queue = deque()
        queue.append(root)
        
        while queue:

            node = queue.popleft()
            count += 1

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return count
            
```

### 110 [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def godeep(self, node, count):
        if node is None:
            return count
        count += 1
        leftdepth = self.godeep(node.left, count)
        rightdepth = self.godeep(node.right, count)
        return max(leftdepth, rightdepth)
    


    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if not root: return True
        count = 1
        if root.left:
            lc = self.godeep(root.left, count)
        else:
            lc = 1
        if root.right:
            rc = self.godeep(root.right, count)
        else:
            rc = 1
        if abs(lc - rc) > 1:
            return False

        return self.isBalanced(root.left) and self.isBalanced(root.right)
```

### 257[Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)

è¿™é“é¢˜ç›®è¦æ±‚ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­çš„è·¯å¾„ï¼Œæ‰€ä»¥éœ€è¦å‰åºéå†ï¼Œè¿™æ ·æ‰æ–¹ä¾¿è®©çˆ¶èŠ‚ç‚¹æŒ‡å‘å­©å­èŠ‚ç‚¹ï¼Œæ‰¾åˆ°å¯¹åº”çš„è·¯å¾„ã€‚

åœ¨è¿™é“é¢˜ç›®ä¸­å°†ç¬¬ä¸€æ¬¡æ¶‰åŠåˆ°å›æº¯ï¼Œå› ä¸ºæˆ‘ä»¬è¦æŠŠè·¯å¾„è®°å½•ä¸‹æ¥ï¼Œéœ€è¦å›æº¯æ¥å›é€€ä¸€ä¸ªè·¯å¾„å†è¿›å…¥å¦ä¸€ä¸ªè·¯å¾„ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:

        result = []

        def dfs(node, path):
            if not node: return 
            path += str(node.val)
            if not node.left and not node.right:
                result.append(path)
            else:
                path+="->"
                dfs(node.left, path)
                dfs(node.right, path)

        dfs(root, "")
        return result
```

### 404[Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/)

æˆ‘ä»¬å¯ä»¥ç”¨**æ·±åº¦ä¼˜å…ˆéå†ï¼ˆDFSï¼‰**æ¥è§£å†³ï¼Œæ•´ä½“æ€è·¯å¦‚ä¸‹ï¼š

1. **éå†æ•´æ£µæ ‘**ï¼Œæ¯åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°±æ£€æŸ¥å®ƒçš„å·¦å­©å­ã€‚
2. å¦‚æœå·¦å­©å­å­˜åœ¨ï¼Œ**ä¸”æ˜¯å¶å­èŠ‚ç‚¹ï¼ˆæ²¡æœ‰å·¦ã€å³å­èŠ‚ç‚¹ï¼‰**ï¼Œå°±æŠŠå®ƒçš„å€¼åŠ å…¥æ€»å’Œä¸­ã€‚
3. ä¸ç®¡å·¦å­©å­æ˜¯ä¸æ˜¯å¶å­ï¼Œéƒ½è¦**ç»§ç»­é€’å½’åœ°å‘å·¦å³å­æ ‘éå†**ï¼Œç›´åˆ°éå†å®Œæ•´æ£µæ ‘ã€‚
4. æœ€åè¿”å›ç´¯åŠ çš„ç»“æœã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        result = 0
        def dfs(node):
            nonlocal result
            if not node:
                return 
            if node.left and not node.left.right and not node.left.left:
                print(result)
                result += node.left.val
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return result
```

### 513[Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/)

å¯ä»¥ç”¨ **DFS** é€’å½’éå†æ•´æ£µæ ‘ï¼ŒåŒæ—¶è¿½è¸ªä¸¤ä¸ªä¿¡æ¯ï¼š

1. å½“å‰é€’å½’åˆ°çš„æ·±åº¦ï¼ˆ`depth`ï¼‰
2. å½“å‰å‘ç°çš„æœ€æ·±å±‚çº§ï¼ˆ`max_depth`ï¼‰ï¼Œä»¥åŠè¯¥å±‚çš„æœ€å·¦å€¼ï¼ˆ`left_value`ï¼‰

------

#### ğŸ” DFS å®ç°æ ¸å¿ƒé€»è¾‘ï¼š

- ä»æ ¹èŠ‚ç‚¹å¼€å§‹é€’å½’ï¼Œèµ·å§‹æ·±åº¦ä¸º 0ã€‚
- æ¯æ·±å…¥ä¸€å±‚ï¼Œæ·±åº¦åŠ  1ã€‚
- æ¯æ¬¡è®¿é—®**ç¬¬ä¸€ä¸ªåˆ°è¾¾çš„æ–°æ·±åº¦**çš„èŠ‚ç‚¹æ—¶ï¼Œè®°å½•å®ƒçš„å€¼ï¼ˆå› ä¸º DFS æ˜¯å…ˆè®¿é—®å·¦å­æ ‘ï¼Œæ‰€ä»¥è¿™ä¸ªå€¼å°±æ˜¯æœ€å·¦è¾¹çš„ï¼‰ã€‚
- ç”¨ä¸¤ä¸ªå˜é‡æŒç»­æ›´æ–°ï¼š`max_depth` å’Œ `left_value`

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        max_depth = -1
        left_value = 0

        def dfs(node, depth):
            nonlocal max_depth, left_value

            if not node:
                return 
            if depth > max_depth:
                max_depth = depth
                left_value = node.val 


            dfs(node.left, depth +1)
            dfs(node.right, depth +1)

        dfs(root, 0)
        return left_value
```

### 112[Path Sum](https://leetcode.com/problems/path-sum/)



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        result = []

        def dfs(node, sumall):
            if not node:
                return
            sumall += node.val
            if not node.left and not node.right:
                result.append(sumall)
            
            dfs(node.left, sumall)
            dfs(node.right, sumall)

        dfs(root, 0)

        return targetSum in result
```

## ä¿®æ”¹ä¸æ„é€ 

### 226[Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)




```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root: return 
        stack = [root]
        while stack:
            node = stack.pop()
            node.left, node.right = node.right, node.left
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)

        return root
```
### 106[Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

Inorder:ä¸­åºéå†,å·¦æ ¹å³ 9 3 15 20 7

Postorder:å·¦å³æ ¹9 15 7 20 3

**ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯æ ¹èŠ‚ç‚¹ã€‚**

**ä¸­åºéå†ä¸­ï¼Œæ ¹èŠ‚ç‚¹å·¦è¾¹çš„æ˜¯å·¦å­æ ‘ï¼Œå³è¾¹çš„æ˜¯å³å­æ ‘ã€‚**


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not inorder or not postorder:
            return None

        root_val = postorder[-1]
        root = TreeNode(root_val)
        print(root_val)

        root_index = inorder.index(root_val)

        left_in = inorder[:root_index]
        # print(left_in)
        right_in = inorder[root_index+1:]
        # print(right_in)

        left_post = postorder[:len(left_in)]
        # print(left_post)
        right_post = postorder[len(left_in):-1]
        # print(right_post)



        root.left = self.buildTree(left_in, left_post)
        root.right = self.buildTree(right_in, right_post)
        return root
```
### 105



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None
        
        root_val = preorder[0]
        root = TreeNode(root_val)

        index = inorder.index(root_val)
        
        leftin = inorder[:index]
        rightin = inorder[index+1:]

        leftpre = preorder[1:len(leftin)+1]
        rightpre = preorder[len(leftin)+1:]

        root.left = self.buildTree(leftpre, leftin)
        root.right = self.buildTree(rightpre, rightin)
        
        return root
```



### 654[Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)




```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return 
        max_num = max(nums)
        max_index = nums.index(max_num)
        root = TreeNode(max_num)

        lefttree = nums[:max_index]
        righttree = nums[max_index+1:]

        root.left = self.constructMaximumBinaryTree(lefttree)
        root.right = self.constructMaximumBinaryTree(righttree)

        return root
```
### 617[Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/)



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if root1 is None and root2: return root2
        if root2 is None and root1: return root1
        if root1 is None and root2 is None: return

        new_t = TreeNode(root1.val+root2.val)
        new_t.left = self.mergeTrees(root1.left, root2.left)
        new_t.right = self.mergeTrees(root1.right, root2.right)

        return new_t
```

## å±æ€§

### 700[Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if root == None: return

        print("-------{}------".format(root.val))
        
        
        if(root.val == val):
            print("==", root.val)
            return root
        elif(val < root.val):
            print("<")
            return self.searchBST(root.left, val)
        elif(val > root.val):
            print(">")
            return self.searchBST(root.right, val)
```

### 98[Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)



```python
class Solution:

    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def vali(left, node, right):
            if not node: return True
            if not(left < node.val < right): return False
            return vali(left, node.left, node.val) and vali(node.val, node.right, right)

        return vali(float('-inf'), root, float('inf'))

```

### 530[Minimum Absolute Difference in BST](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        prev = None
        min_diff = float('inf')
        def inorder(node):
            nonlocal prev, min_diff
            if not node: return
            inorder(node.left)

            if prev is not None:
                min_diff = min(min_diff, abs(node.val - prev))
            prev = node.val

            inorder(node.right)

        inorder(root)
        return min_diff
```

### 501[Find Mode in Binary Search Tree](https://leetcode.com/problems/find-mode-in-binary-search-tree/)

å¯¹æ•´æ£µæ ‘è¿›è¡Œ **ä¸­åºéå†**ï¼ˆBST ä¸­åºæ˜¯é€’å¢çš„ï¼‰

ä½¿ç”¨ä¸€ä¸ªå­—å…¸æˆ–è®¡æ•°å™¨è®°å½•æ¯ä¸ªå€¼å‡ºç°çš„æ¬¡æ•°

æ‰¾å‡ºæœ€å¤§é¢‘ç‡ï¼ŒæŠŠæ‰€æœ‰å‡ºç°è¿™ä¸ªé¢‘ç‡çš„å€¼è¿”å›

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        freq = defaultdict(int)

        def inorder(root):
            nonlocal freq
            if root.left:
                inorder(root.left)
            freq[root.val] += 1
            if root.right:
                inorder(root.right)
        inorder(root)
        max_count = max(freq.values())
        return [val for val, count in freq.items() if count == max_count]
```

### 538[Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/)



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        total = 0
        def dfs(node):
            nonlocal total
            if not node: return 

            dfs(node.right)
            total += node.val
            node.val = total
            dfs(node.left)

        dfs(root)
        return root
```

## å…¬å…±ç¥–å…ˆ:

### 236[Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

#### 1. é€’å½’éå†ï¼ˆDFSï¼‰ï¼š

- åˆ©ç”¨é€’å½’å‡½æ•°ä»æ ¹èŠ‚ç‚¹å¼€å§‹å‘ä¸‹æœç´¢ã€‚
- æ€è€ƒï¼šå½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯ `p` æˆ– `q`ï¼Ÿæ˜¯å¦åœ¨å…¶å·¦å³å­æ ‘ä¸­èƒ½æ‰¾åˆ°å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Ÿ

#### 2. ä¸‰ç§æƒ…å†µï¼š

- å¦‚æœåœ¨**å·¦å­æ ‘**æ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåœ¨**å³å­æ ‘**æ‰¾åˆ°å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå½“å‰èŠ‚ç‚¹å°±æ˜¯ LCAã€‚
- å¦‚æœåœ¨å½“å‰å­æ ‘ä¸­åªæ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦ä¸€ä¸ªèŠ‚ç‚¹ä¸åœ¨è¿™æ£µå­æ ‘ä¸­ï¼Œé‚£ä¹ˆå¾€ä¸Šä¼ é€’è¿™ä¸ªå·²æ‰¾åˆ°çš„èŠ‚ç‚¹ã€‚
- å¦‚æœå½“å‰èŠ‚ç‚¹å°±æ˜¯ `p` æˆ– `q`ï¼Œä¹Ÿåº”è¯¥ä½œä¸ºç»“æœçš„ä¸€éƒ¨åˆ†å‘ä¸Šä¼ é€’ã€‚

#### 3. é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼š

- å½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œè¿”å› `None`ã€‚
- å½“å‰èŠ‚ç‚¹ç­‰äº `p` æˆ– `q`ï¼Œç›´æ¥è¿”å›å½“å‰èŠ‚ç‚¹ã€‚

#### 4. å›æº¯çš„æ ¸å¿ƒï¼š

- ä»ä¸‹å¾€ä¸Šé€æ­¥åˆ¤æ–­å·¦å³å­æ ‘æ˜¯å¦åŒ…å«ç›®æ ‡èŠ‚ç‚¹ï¼Œæ ¹æ®è¿”å›ç»“æœæ¥åˆ¤æ–­è°æ˜¯ LCAã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        def dfs(node):
            if node is None: return None

            if (node == p or node == q): return node

            leftn = dfs(node.left)
            rightn = dfs(node.right)

            if leftn and rightn: return node

            if not leftn: return rightn
            elif not rightn: return leftn 
        return dfs(root)
```

### 235[Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

#### æ ¸å¿ƒé€»è¾‘ï¼š**åˆ©ç”¨ BST çš„å¤§å°å…³ç³»æ¥èµ°è·¯ï¼**

ç»™ä½ ä¸¤ä¸ªèŠ‚ç‚¹ `p` å’Œ `q`ï¼Œä½ ä»æ ¹èŠ‚ç‚¹å¼€å§‹åˆ¤æ–­ï¼š

#### âœ… æƒ…å†µä¸€ï¼š

å¦‚æœï¼š

```
p.val < root.val  ä¸”  q.val < root.val
```

è¯´æ˜ `p` å’Œ `q` éƒ½åœ¨å½“å‰èŠ‚ç‚¹çš„**å·¦å­æ ‘**é‡Œ â€”â€” é€’å½’æˆ–è¿­ä»£å¾€å·¦èµ°ã€‚

#### âœ… æƒ…å†µäºŒï¼š

å¦‚æœï¼š

```
p.val > root.val  ä¸”  q.val > root.val
```

è¯´æ˜ `p` å’Œ `q` éƒ½åœ¨å½“å‰èŠ‚ç‚¹çš„**å³å­æ ‘**é‡Œ â€”â€” å¾€å³èµ°ã€‚

#### âœ… æƒ…å†µä¸‰ï¼ˆæœ€é‡è¦ï¼‰ï¼š

å¦‚æœï¼š

```
ä¸€ä¸ªåœ¨å·¦ï¼Œä¸€ä¸ªåœ¨å³ï¼Œæˆ–è€…å½“å‰èŠ‚ç‚¹å°±æ˜¯å…¶ä¸­ä¸€ä¸ª
```

é‚£ä¹ˆå½“å‰èŠ‚ç‚¹å°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆLCAï¼‰ã€‚

å› ä¸ºè¿™æ˜¯å®ƒä»¬è·¯å¾„**ç¬¬ä¸€æ¬¡åˆ†å‰çš„åœ°æ–¹**ï¼Œæˆ–è€…è¯´æ˜¯â€œå…±åŒè·¯è¿‡çš„æœ€ä½ç‚¹â€ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        def dfs(node):
            if not node:
                return None
            if(p.val>node.val and q.val<node.val): 
                return node
            if(p.val<node.val and q.val>node.val): 
                return node
            if p.val == node.val or q.val == node.val: 
                return node

            if(p.val < node.val and q.val < node.val): 
                return dfs(node.left)
            if(p.val > node.val and q.val > node.val): 
                return dfs(node.right)

        return dfs(root)
```



## æœç´¢æ ‘ä¿®æ”¹ä¸æ„é€ 

### 701[Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/)

#### ğŸŒ² BST çš„æ€§è´¨å¤ä¹ ï¼š

> å¯¹äºä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ï¼š

- æ‰€æœ‰å·¦å­æ ‘çš„èŠ‚ç‚¹å€¼éƒ½ **å°äºå½“å‰èŠ‚ç‚¹å€¼**ï¼›
- æ‰€æœ‰å³å­æ ‘çš„èŠ‚ç‚¹å€¼éƒ½ **å¤§äºå½“å‰èŠ‚ç‚¹å€¼**ã€‚

è¿™ä¸ªæ€§è´¨æ˜¯æˆ‘ä»¬æ’å…¥çš„å…³é”®ã€‚

------

#### ğŸ§  è§£é¢˜æ€è·¯ï¼š

#### æ–¹æ³•ä¸€ï¼š**é€’å½’æ’å…¥ï¼ˆDFSï¼‰**

1. ä» `root` å¼€å§‹æ¯”è¾ƒï¼š
   - å¦‚æœ `val < node.val`ï¼Œå¾€å·¦å­æ ‘é€’å½’ï¼›
   - å¦‚æœ `val > node.val`ï¼Œå¾€å³å­æ ‘é€’å½’ï¼›
2. å½“ä½ å‘ç°å¯¹åº”çš„å·¦/å³å­èŠ‚ç‚¹æ˜¯ `None`ï¼Œå°±**æŠŠæ–°èŠ‚ç‚¹æ’åœ¨è¿™é‡Œ**ã€‚

ğŸ‘‰ å› ä¸ºé¢˜ç›®ä¿è¯æ–°å€¼åœ¨æ ‘ä¸­ä¸å­˜åœ¨ï¼Œæ‰€ä»¥ä¸éœ€è¦è€ƒè™‘ç­‰äºçš„æƒ…å†µã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        def dfs(node):
            if node is None: 
                return TreeNode(val)
            if node.val > val: node.left = dfs(node.left)
            if node.val < val: node.right = dfs(node.right)
            return node

        return dfs(root)

```

### 450[ Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/)

- ç¬¬ä¸€ç§æƒ…å†µï¼šæ²¡æ‰¾åˆ°åˆ é™¤çš„èŠ‚ç‚¹ï¼Œéå†åˆ°ç©ºèŠ‚ç‚¹ç›´æ¥è¿”å›äº†
- æ‰¾åˆ°åˆ é™¤çš„èŠ‚ç‚¹
  - ç¬¬äºŒç§æƒ…å†µï¼šå·¦å³å­©å­éƒ½ä¸ºç©ºï¼ˆå¶å­èŠ‚ç‚¹ï¼‰ï¼Œç›´æ¥åˆ é™¤èŠ‚ç‚¹ï¼Œ è¿”å›NULLä¸ºæ ¹èŠ‚ç‚¹
  - ç¬¬ä¸‰ç§æƒ…å†µï¼šåˆ é™¤èŠ‚ç‚¹çš„å·¦å­©å­ä¸ºç©ºï¼Œå³å­©å­ä¸ä¸ºç©ºï¼Œåˆ é™¤èŠ‚ç‚¹ï¼Œå³å­©å­è¡¥ä½ï¼Œè¿”å›å³å­©å­ä¸ºæ ¹èŠ‚ç‚¹
  - ç¬¬å››ç§æƒ…å†µï¼šåˆ é™¤èŠ‚ç‚¹çš„å³å­©å­ä¸ºç©ºï¼Œå·¦å­©å­ä¸ä¸ºç©ºï¼Œåˆ é™¤èŠ‚ç‚¹ï¼Œå·¦å­©å­è¡¥ä½ï¼Œè¿”å›å·¦å­©å­ä¸ºæ ¹èŠ‚ç‚¹
  - ç¬¬äº”ç§æƒ…å†µï¼šå·¦å³å­©å­èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œåˆ™å°†åˆ é™¤èŠ‚ç‚¹çš„å·¦å­æ ‘å¤´ç»“ç‚¹ï¼ˆå·¦å­©å­ï¼‰æ”¾åˆ°åˆ é™¤èŠ‚ç‚¹çš„å³å­æ ‘çš„æœ€å·¦é¢èŠ‚ç‚¹çš„å·¦å­©å­ä¸Šï¼Œè¿”å›åˆ é™¤èŠ‚ç‚¹å³å­©å­ä¸ºæ–°çš„æ ¹èŠ‚ç‚¹ã€‚

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root: return root

        if root.val == key:
            if not root.right:
                return root.left
            
            cur = root.right
            while cur.left:
                cur = cur.left
            root.val, cur.val = cur.val, root.val

        root.left = self.deleteNode(root.left, key)
        root.right = self.deleteNode(root.right, key)

        return root
            
```

### 669[Trim a Binary Search Tree](https://leetcode.com/problems/trim-a-binary-search-tree/)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        if not root:
            return root

        if root.val < low:
            return self.trimBST(root.right, low, high)
        elif root.val > high:
            return self.trimBST(root.left, low, high)

        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        return root
```

### 108[Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        
        mid = len(nums) // 2
        middle = TreeNode(nums[mid])
        middle.left = self.sortedArrayToBST(nums[:mid])
        middle.right = self.sortedArrayToBST(nums[mid+1:])
        return middle
```

