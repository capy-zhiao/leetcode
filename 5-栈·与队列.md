# 理论基础

------

## 🧠 栈（Stack）理论基础

- **定义**：栈是一种 **后进先出（LIFO, Last In First Out）** 的数据结构。
- **基本操作**：
  - `push`（入栈）：将元素放到栈顶。
  - `pop`（出栈）：移除并返回栈顶元素。
  - `peek` 或 `top`：查看栈顶元素但不移除。
  - `is_empty`：检查栈是否为空。
  - `size`：栈的大小。

------

## 🧠 队列（Queue）理论基础

- **定义**：队列是一种 **先进先出（FIFO, First In First Out）** 的数据结构。
- **基本操作**：
  - `enqueue`（入队）：将元素添加到队尾。queue.append(x)
  - `dequeue`（出队）：移除并返回队首元素。queue.popleft()
  - `peek` 或 `front`：查看队首元素但不移除。
  - `is_empty`：检查队列是否为空。
  - `size`：队列的大小。

------

## 🐍 Python 中的实现

### ✅ 栈的实现（使用列表）

```python
stack = []

# 入栈
stack.append(10)
stack.append(20)

# 出栈
top = stack.pop()  # 20

# 查看栈顶元素
if stack:
    top_element = stack[-1]

# 是否为空
is_empty = len(stack) == 0
```

------

### ✅ 队列的实现（使用 collections.deque）

```python
from collections import deque

queue = deque()

# 入队
queue.append(10)
queue.append(20)

# 出队
first = queue.popleft()  # 10

# 查看队首
if queue:
    front_element = queue[0]

# 是否为空
is_empty = len(queue) == 0
```

------

## 📌 常用方法总结

| 类型    | 方法         | 说明                       |
| ------- | ------------ | -------------------------- |
| 栈      | `append(x)`  | 入栈                       |
| 栈/队列 | `pop()`      | 出栈                       |
| 栈      | `[-1]`       | 查看栈顶元素最后一个字符哈 |
| 栈      | `len(stack)` | 栈的大小                   |
| 队列    | `append(x)`  | 入队（队尾）               |
| 队列    | `popleft()`  | 出队（队首）               |
| 队列    | `[0]`        | 查看队首元素               |
| 队列    | `len(queue)` | 队列的大小                 |

------

# easy [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)

## descriptipn

Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).

Implement the `MyQueue` class:

- `void push(int x)` Pushes element x to the back of the queue.
- `int pop()` Removes the element from the front of the queue and returns it.
- `int peek()` Returns the element at the front of the queue.
- `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.

**Notes:**

- You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.
- Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations. 

**Example 1:**

```
Input
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

## solution

```python
class MyQueue:
    def trans(self):
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())

    def __init__(self):
        self.stack_in = []
        self.stack_out = []

    def push(self, x: int) -> None:
        self.stack_in.append(x)

    def pop(self) -> int:
        self.trans()
        return self.stack_out.pop()

    def peek(self) -> int:
        self.trans()
        return self.stack_out[-1]

    def empty(self) -> bool:
        return not self.stack_out and not self.stack_in


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
```



## thought

用两个栈：

- `stack_in`: 用于入队（push）
- `stack_out`: 用于出队（pop）和查看队首（peek）

工作机制：

1. **push(x)**：直接把元素压入 `stack_in`
2. **pop() / peek()**：
   - 如果 `stack_out` 为空，把 `stack_in` 里的所有元素「倒腾」过去（依次 pop 并 push 到 `stack_out`），这样元素顺序就变成了 FIFO。
   - 然后从 `stack_out` 出队或查看队首。
3. **empty()**：两个栈都为空才是真的空

# easy [225. Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)

## descriptipn

Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).

Implement the `MyStack` class:

- `void push(int x)` Pushes element x to the top of the stack.
- `int pop()` Removes the element on the top of the stack and returns it.
- `int top()` Returns the element on the top of the stack.
- `boolean empty()` Returns `true` if the stack is empty, `false` otherwise.

**Notes:**

- You must use **only** standard operations of a queue, which means that only `push to back`, `peek/pop from front`, `size` and `is empty` operations are valid.
- Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.

**Example 1:**

```
Input
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
```

## solution

```python
class MyStack:

    def __init__(self):
        self.queue1 = deque()
        self.queue2 = deque()

    def push(self, x: int) -> None:
        self.queue2.append(x)
        while self.queue1:
            self.queue2.append(self.queue1.popleft())
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self) -> int:
        return self.queue1.popleft()

    def top(self) -> int:
        return self.queue1[0]

    def empty(self) -> bool:
        return not self.queue1
```



## thought

### 使用两个队列

- `queue1`: 主队列，始终保存当前栈的元素
- `queue2`: 辅助队列，用来协助元素的重新排列

### 🌟 操作原理

- **push(x)**：先将 `x` 加入空的 `queue2`，然后把 `queue1` 中的所有元素依次出队加到 `queue2`，最后交换两个队列的引用。
  - 这样，`queue2` 的队首就是新加入的元素（模拟栈顶）
- **pop() / top()**：直接访问 `queue1` 的队首即可
- **empty()**：看 `queue1` 是否为空

# easy [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

## descriptipn

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

**Input:** s = "()"

**Output:** true

**Example 2:**

**Input:** s = "()[]{}"

**Output:** true

**Example 3:**

**Input:** s = "(]"

**Output:** false

**Example 4:**

**Input:** s = "([])"

**Output:** true

## solution

```python
class Solution:
    def isValid(self, s: str) -> bool:
        notes = {'(':')', '{':'}', '[':']'}
        stack_left = []

        for note in s:
            if note in notes:
                stack_left.append(note)
            else:
                if not stack_left or note != notes[stack_left[-1]]:
                    return False
                stack_left.pop()
        
        if len(stack_left) >0:
            return False
        else:
            return True
```



## thought

Woke我这个最慢,我看一下最快的怎么写的:

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            if c == '(':
                stack.append(')')
            elif c == '{':
                stack.append('}')
            elif c == '[':
                stack.append(']')
            elif not stack or stack.pop() != c:
                return False
        return not stack

```

天才

# easy [1047. Remove All Adjacent Duplicates In String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/)

## descriptipn

You are given a string `s` consisting of lowercase English letters. A **duplicate removal** consists of choosing two **adjacent** and **equal** letters and removing them.

We repeatedly make **duplicate removals** on `s` until we no longer can.

Return *the final string after all such duplicate removals have been made*. It can be proven that the answer is **unique**.

**Example 1:**

```
Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
```

**Example 2:**

```
Input: s = "azxxzy"
Output: "ay"
```

 

## solution

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        strstack = []

        for c in s:
            if strstack and strstack[-1] == c:
                strstack.pop()
            else:
                strstack.append(c)
        return ''.join(strstack)
```



## thought



# Med [150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

## descriptipn

You are given an array of strings `tokens` that represents an arithmetic expression in a [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).

Evaluate the expression. Return *an integer that represents the value of the expression*.

**Note** that:

- The valid operators are `'+'`, `'-'`, `'*'`, and `'/'`.
- Each operand may be an integer or another expression.
- The division between two integers always **truncates toward zero**.
- There will not be any division by zero.
- The input represents a valid arithmetic expression in a reverse polish notation.
- The answer and all the intermediate calculations can be represented in a **32-bit** integer.

**Example 1:**

```
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
```

**Example 2:**

```
Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
```

**Example 3:**

```
Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

## solution

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        result = 0
        stack = []
        operators = {'+', '-', '*', '/'}

        for token in tokens:
            if token in operators:
                num2 = stack.pop()
                num1 = stack.pop()
                
                if token == '+':
                    result = num1 + num2
                elif token == '-':
                    result = num1 - num2
                elif token == '*':
                    result = num1 * num2
                elif token == '/':
                    result = int(num1 / num2)
                
                stack.append(result)
            else:
                stack.append(int(token))

        return stack[0]
```



## thought



# Hard [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

## descriptipn

You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return *the max sliding window*.

**Example 1:**

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

## solution

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        result = []
        window = deque()

        # 遍历 nums，每次更新窗口和结果
        for i in range(len(nums)):
            # 移除队首不在窗口范围内的元素（i - k）
            if window and window[0] <= i - k:
                window.popleft()

            # 从队尾移除所有比当前 nums[i] 小的元素
            while window and nums[window[-1]] < nums[i]:
                window.pop()

            # 将当前索引 i 加入队尾
            window.append(i)
            
            # 当 i >= k - 1 时，把队首的 nums[索引] 加入 result
            if i >= k - 1:
                result.append(nums[window[0]])

        
        return result
```



## thought

好难..

# Med [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

## descriptipn

Given an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.

**Example 1:**

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

## solution

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        c = Counter(nums)
        return [item[0] for item in c.most_common(k)]
```

## thought



