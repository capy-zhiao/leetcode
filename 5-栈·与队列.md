# ÁêÜËÆ∫Âü∫Á°Ä

------

## üß† Ê†àÔºàStackÔºâÁêÜËÆ∫Âü∫Á°Ä

- **ÂÆö‰πâ**ÔºöÊ†àÊòØ‰∏ÄÁßç **ÂêéËøõÂÖàÂá∫ÔºàLIFO, Last In First OutÔºâ** ÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇ
- **Âü∫Êú¨Êìç‰Ωú**Ôºö
  - `push`ÔºàÂÖ•Ê†àÔºâÔºöÂ∞ÜÂÖÉÁ¥†ÊîæÂà∞Ê†àÈ°∂„ÄÇ
  - `pop`ÔºàÂá∫Ê†àÔºâÔºöÁßªÈô§Âπ∂ËøîÂõûÊ†àÈ°∂ÂÖÉÁ¥†„ÄÇ
  - `peek` Êàñ `top`ÔºöÊü•ÁúãÊ†àÈ°∂ÂÖÉÁ¥†‰ΩÜ‰∏çÁßªÈô§„ÄÇ
  - `is_empty`ÔºöÊ£ÄÊü•Ê†àÊòØÂê¶‰∏∫Á©∫„ÄÇ
  - `size`ÔºöÊ†àÁöÑÂ§ßÂ∞è„ÄÇ

------

## üß† ÈòüÂàóÔºàQueueÔºâÁêÜËÆ∫Âü∫Á°Ä

- **ÂÆö‰πâ**ÔºöÈòüÂàóÊòØ‰∏ÄÁßç **ÂÖàËøõÂÖàÂá∫ÔºàFIFO, First In First OutÔºâ** ÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇ
- **Âü∫Êú¨Êìç‰Ωú**Ôºö
  - `enqueue`ÔºàÂÖ•ÈòüÔºâÔºöÂ∞ÜÂÖÉÁ¥†Ê∑ªÂä†Âà∞ÈòüÂ∞æ„ÄÇqueue.append(x)
  - `dequeue`ÔºàÂá∫ÈòüÔºâÔºöÁßªÈô§Âπ∂ËøîÂõûÈòüÈ¶ñÂÖÉÁ¥†„ÄÇqueue.popleft()
  - `peek` Êàñ `front`ÔºöÊü•ÁúãÈòüÈ¶ñÂÖÉÁ¥†‰ΩÜ‰∏çÁßªÈô§„ÄÇ
  - `is_empty`ÔºöÊ£ÄÊü•ÈòüÂàóÊòØÂê¶‰∏∫Á©∫„ÄÇ
  - `size`ÔºöÈòüÂàóÁöÑÂ§ßÂ∞è„ÄÇ

------

## üêç Python ‰∏≠ÁöÑÂÆûÁé∞

### ‚úÖ Ê†àÁöÑÂÆûÁé∞Ôºà‰ΩøÁî®ÂàóË°®Ôºâ

```python
stack = []

# ÂÖ•Ê†à
stack.append(10)
stack.append(20)

# Âá∫Ê†à
top = stack.pop()  # 20

# Êü•ÁúãÊ†àÈ°∂ÂÖÉÁ¥†
if stack:
    top_element = stack[-1]

# ÊòØÂê¶‰∏∫Á©∫
is_empty = len(stack) == 0
```

------

### ‚úÖ ÈòüÂàóÁöÑÂÆûÁé∞Ôºà‰ΩøÁî® collections.dequeÔºâ

```python
from collections import deque

queue = deque()

# ÂÖ•Èòü
queue.append(10)
queue.append(20)

# Âá∫Èòü
first = queue.popleft()  # 10

# Êü•ÁúãÈòüÈ¶ñ
if queue:
    front_element = queue[0]

# ÊòØÂê¶‰∏∫Á©∫
is_empty = len(queue) == 0
```

------

## üìå Â∏∏Áî®ÊñπÊ≥ïÊÄªÁªì

| Á±ªÂûã | ÊñπÊ≥ï         | ËØ¥Êòé                       |
| ---- | ------------ | -------------------------- |
| Ê†à   | `append(x)`  | ÂÖ•Ê†à                       |
| Ê†à   | `pop()`      | Âá∫Ê†à                       |
| Ê†à   | `[-1]`       | Êü•ÁúãÊ†àÈ°∂ÂÖÉÁ¥†ÊúÄÂêé‰∏Ä‰∏™Â≠óÁ¨¶Âìà |
| Ê†à   | `len(stack)` | Ê†àÁöÑÂ§ßÂ∞è                   |
| ÈòüÂàó | `append(x)`  | ÂÖ•ÈòüÔºàÈòüÂ∞æÔºâ               |
| ÈòüÂàó | `popleft()`  | Âá∫ÈòüÔºàÈòüÈ¶ñÔºâ               |
| ÈòüÂàó | `[0]`        | Êü•ÁúãÈòüÈ¶ñÂÖÉÁ¥†               |
| ÈòüÂàó | `len(queue)` | ÈòüÂàóÁöÑÂ§ßÂ∞è                 |

------

# easy [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)

## descriptipn

Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).

Implement the `MyQueue` class:

- `void push(int x)` Pushes element x to the back of the queue.
- `int pop()` Removes the element from the front of the queue and returns it.
- `int peek()` Returns the element at the front of the queue.
- `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.

**Notes:**

- You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.
- Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations. 

**Example 1:**

```
Input
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

## solution

```python
class MyQueue:
    def trans(self):
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())

    def __init__(self):
        self.stack_in = []
        self.stack_out = []

    def push(self, x: int) -> None:
        self.stack_in.append(x)

    def pop(self) -> int:
        self.trans()
        return self.stack_out.pop()

    def peek(self) -> int:
        self.trans()
        return self.stack_out[-1]

    def empty(self) -> bool:
        return not self.stack_out and not self.stack_in


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
```



## thought

Áî®‰∏§‰∏™Ê†àÔºö

- `stack_in`: Áî®‰∫éÂÖ•ÈòüÔºàpushÔºâ
- `stack_out`: Áî®‰∫éÂá∫ÈòüÔºàpopÔºâÂíåÊü•ÁúãÈòüÈ¶ñÔºàpeekÔºâ

Â∑•‰ΩúÊú∫Âà∂Ôºö

1. **push(x)**ÔºöÁõ¥Êé•ÊääÂÖÉÁ¥†ÂéãÂÖ• `stack_in`
2. **pop() / peek()**Ôºö
   - Â¶ÇÊûú `stack_out` ‰∏∫Á©∫ÔºåÊää `stack_in` ÈáåÁöÑÊâÄÊúâÂÖÉÁ¥†„ÄåÂÄíËÖæ„ÄçËøáÂéªÔºà‰æùÊ¨° pop Âπ∂ push Âà∞ `stack_out`ÔºâÔºåËøôÊ†∑ÂÖÉÁ¥†È°∫Â∫èÂ∞±ÂèòÊàê‰∫Ü FIFO„ÄÇ
   - ÁÑ∂Âêé‰ªé `stack_out` Âá∫ÈòüÊàñÊü•ÁúãÈòüÈ¶ñ„ÄÇ
3. **empty()**Ôºö‰∏§‰∏™Ê†àÈÉΩ‰∏∫Á©∫ÊâçÊòØÁúüÁöÑÁ©∫

# easy [225. Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)

## descriptipn

Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).

Implement the `MyStack` class:

- `void push(int x)` Pushes element x to the top of the stack.
- `int pop()` Removes the element on the top of the stack and returns it.
- `int top()` Returns the element on the top of the stack.
- `boolean empty()` Returns `true` if the stack is empty, `false` otherwise.

**Notes:**

- You must use **only** standard operations of a queue, which means that only `push to back`, `peek/pop from front`, `size` and `is empty` operations are valid.
- Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.

**Example 1:**

```
Input
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
```

## solution

```python
class MyStack:

    def __init__(self):
        self.queue1 = deque()
        self.queue2 = deque()

    def push(self, x: int) -> None:
        self.queue2.append(x)
        while self.queue1:
            self.queue2.append(self.queue1.popleft())
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self) -> int:
        return self.queue1.popleft()

    def top(self) -> int:
        return self.queue1[0]

    def empty(self) -> bool:
        return not self.queue1
```



## thought

### ‰ΩøÁî®‰∏§‰∏™ÈòüÂàó

- `queue1`: ‰∏ªÈòüÂàóÔºåÂßãÁªà‰øùÂ≠òÂΩìÂâçÊ†àÁöÑÂÖÉÁ¥†
- `queue2`: ËæÖÂä©ÈòüÂàóÔºåÁî®Êù•ÂçèÂä©ÂÖÉÁ¥†ÁöÑÈáçÊñ∞ÊéíÂàó

### üåü Êìç‰ΩúÂéüÁêÜ

- **push(x)**ÔºöÂÖàÂ∞Ü `x` Âä†ÂÖ•Á©∫ÁöÑ `queue2`ÔºåÁÑ∂ÂêéÊää `queue1` ‰∏≠ÁöÑÊâÄÊúâÂÖÉÁ¥†‰æùÊ¨°Âá∫ÈòüÂä†Âà∞ `queue2`ÔºåÊúÄÂêé‰∫§Êç¢‰∏§‰∏™ÈòüÂàóÁöÑÂºïÁî®„ÄÇ
  - ËøôÊ†∑Ôºå`queue2` ÁöÑÈòüÈ¶ñÂ∞±ÊòØÊñ∞Âä†ÂÖ•ÁöÑÂÖÉÁ¥†ÔºàÊ®°ÊãüÊ†àÈ°∂Ôºâ
- **pop() / top()**ÔºöÁõ¥Êé•ËÆøÈóÆ `queue1` ÁöÑÈòüÈ¶ñÂç≥ÂèØ
- **empty()**ÔºöÁúã `queue1` ÊòØÂê¶‰∏∫Á©∫

# easy [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

## descriptipn

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

**Input:** s = "()"

**Output:** true

**Example 2:**

**Input:** s = "()[]{}"

**Output:** true

**Example 3:**

**Input:** s = "(]"

**Output:** false

**Example 4:**

**Input:** s = "([])"

**Output:** true

## solution

```python
class Solution:
    def isValid(self, s: str) -> bool:
        notes = {'(':')', '{':'}', '[':']'}
        stack_left = []

        for note in s:
            if note in notes:
                stack_left.append(note)
            else:
                if not stack_left or note != notes[stack_left[-1]]:
                    return False
                stack_left.pop()
        
        if len(stack_left) >0:
            return False
        else:
            return True
```



## thought

WokeÊàëËøô‰∏™ÊúÄÊÖ¢,ÊàëÁúã‰∏Ä‰∏ãÊúÄÂø´ÁöÑÊÄé‰πàÂÜôÁöÑ:

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            if c == '(':
                stack.append(')')
            elif c == '{':
                stack.append('}')
            elif c == '[':
                stack.append(']')
            elif not stack or stack.pop() != c:
                return False
        return not stack

```

Â§©Êâç

# easy [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)

## descriptipn



## solution

```python

```



## thought



# easy [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)

## descriptipn



## solution

```python

```



## thought



# easy [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)

## descriptipn



## solution

```python

```



## thought



# easy [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)

## descriptipn



## solution

```python

```



## thought



