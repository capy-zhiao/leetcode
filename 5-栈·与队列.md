# ç†è®ºåŸºç¡€

------

## ğŸ§  æ ˆï¼ˆStackï¼‰ç†è®ºåŸºç¡€

- **å®šä¹‰**ï¼šæ ˆæ˜¯ä¸€ç§ **åè¿›å…ˆå‡ºï¼ˆLIFO, Last In First Outï¼‰** çš„æ•°æ®ç»“æ„ã€‚
- **åŸºæœ¬æ“ä½œ**ï¼š
  - `push`ï¼ˆå…¥æ ˆï¼‰ï¼šå°†å…ƒç´ æ”¾åˆ°æ ˆé¡¶ã€‚
  - `pop`ï¼ˆå‡ºæ ˆï¼‰ï¼šç§»é™¤å¹¶è¿”å›æ ˆé¡¶å…ƒç´ ã€‚
  - `peek` æˆ– `top`ï¼šæŸ¥çœ‹æ ˆé¡¶å…ƒç´ ä½†ä¸ç§»é™¤ã€‚
  - `is_empty`ï¼šæ£€æŸ¥æ ˆæ˜¯å¦ä¸ºç©ºã€‚
  - `size`ï¼šæ ˆçš„å¤§å°ã€‚

------

## ğŸ§  é˜Ÿåˆ—ï¼ˆQueueï¼‰ç†è®ºåŸºç¡€

- **å®šä¹‰**ï¼šé˜Ÿåˆ—æ˜¯ä¸€ç§ **å…ˆè¿›å…ˆå‡ºï¼ˆFIFO, First In First Outï¼‰** çš„æ•°æ®ç»“æ„ã€‚
- **åŸºæœ¬æ“ä½œ**ï¼š
  - `enqueue`ï¼ˆå…¥é˜Ÿï¼‰ï¼šå°†å…ƒç´ æ·»åŠ åˆ°é˜Ÿå°¾ã€‚queue.append(x)
  - `dequeue`ï¼ˆå‡ºé˜Ÿï¼‰ï¼šç§»é™¤å¹¶è¿”å›é˜Ÿé¦–å…ƒç´ ã€‚queue.popleft()
  - `peek` æˆ– `front`ï¼šæŸ¥çœ‹é˜Ÿé¦–å…ƒç´ ä½†ä¸ç§»é™¤ã€‚
  - `is_empty`ï¼šæ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚
  - `size`ï¼šé˜Ÿåˆ—çš„å¤§å°ã€‚

------

## ğŸ Python ä¸­çš„å®ç°

### âœ… æ ˆçš„å®ç°ï¼ˆä½¿ç”¨åˆ—è¡¨ï¼‰

```python
stack = []

# å…¥æ ˆ
stack.append(10)
stack.append(20)

# å‡ºæ ˆ
top = stack.pop()  # 20

# æŸ¥çœ‹æ ˆé¡¶å…ƒç´ 
if stack:
    top_element = stack[-1]

# æ˜¯å¦ä¸ºç©º
is_empty = len(stack) == 0
```

------

### âœ… é˜Ÿåˆ—çš„å®ç°ï¼ˆä½¿ç”¨ collections.dequeï¼‰

```python
from collections import deque

queue = deque()

# å…¥é˜Ÿ
queue.append(10)
queue.append(20)

# å‡ºé˜Ÿ
first = queue.popleft()  # 10

# æŸ¥çœ‹é˜Ÿé¦–
if queue:
    front_element = queue[0]

# æ˜¯å¦ä¸ºç©º
is_empty = len(queue) == 0
```

------

## ğŸ“Œ å¸¸ç”¨æ–¹æ³•æ€»ç»“

| ç±»å‹    | æ–¹æ³•         | è¯´æ˜                       |
| ------- | ------------ | -------------------------- |
| æ ˆ      | `append(x)`  | å…¥æ ˆ                       |
| æ ˆ/é˜Ÿåˆ— | `pop()`      | å‡ºæ ˆ                       |
| æ ˆ      | `[-1]`       | æŸ¥çœ‹æ ˆé¡¶å…ƒç´ æœ€åä¸€ä¸ªå­—ç¬¦å“ˆ |
| æ ˆ      | `len(stack)` | æ ˆçš„å¤§å°                   |
| é˜Ÿåˆ—    | `append(x)`  | å…¥é˜Ÿï¼ˆé˜Ÿå°¾ï¼‰               |
| é˜Ÿåˆ—    | `popleft()`  | å‡ºé˜Ÿï¼ˆé˜Ÿé¦–ï¼‰               |
| é˜Ÿåˆ—    | `[0]`        | æŸ¥çœ‹é˜Ÿé¦–å…ƒç´                |
| é˜Ÿåˆ—    | `len(queue)` | é˜Ÿåˆ—çš„å¤§å°                 |

------

# easy [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)

## descriptipn

Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).

Implement the `MyQueue` class:

- `void push(int x)` Pushes element x to the back of the queue.
- `int pop()` Removes the element from the front of the queue and returns it.
- `int peek()` Returns the element at the front of the queue.
- `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.

**Notes:**

- You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.
- Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations. 

**Example 1:**

```
Input
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

## solution

```python
class MyQueue:
    def trans(self):
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())

    def __init__(self):
        self.stack_in = []
        self.stack_out = []

    def push(self, x: int) -> None:
        self.stack_in.append(x)

    def pop(self) -> int:
        self.trans()
        return self.stack_out.pop()

    def peek(self) -> int:
        self.trans()
        return self.stack_out[-1]

    def empty(self) -> bool:
        return not self.stack_out and not self.stack_in


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
```



## thought

ç”¨ä¸¤ä¸ªæ ˆï¼š

- `stack_in`: ç”¨äºå…¥é˜Ÿï¼ˆpushï¼‰
- `stack_out`: ç”¨äºå‡ºé˜Ÿï¼ˆpopï¼‰å’ŒæŸ¥çœ‹é˜Ÿé¦–ï¼ˆpeekï¼‰

å·¥ä½œæœºåˆ¶ï¼š

1. **push(x)**ï¼šç›´æ¥æŠŠå…ƒç´ å‹å…¥ `stack_in`
2. **pop() / peek()**ï¼š
   - å¦‚æœ `stack_out` ä¸ºç©ºï¼ŒæŠŠ `stack_in` é‡Œçš„æ‰€æœ‰å…ƒç´ ã€Œå€’è…¾ã€è¿‡å»ï¼ˆä¾æ¬¡ pop å¹¶ push åˆ° `stack_out`ï¼‰ï¼Œè¿™æ ·å…ƒç´ é¡ºåºå°±å˜æˆäº† FIFOã€‚
   - ç„¶åä» `stack_out` å‡ºé˜Ÿæˆ–æŸ¥çœ‹é˜Ÿé¦–ã€‚
3. **empty()**ï¼šä¸¤ä¸ªæ ˆéƒ½ä¸ºç©ºæ‰æ˜¯çœŸçš„ç©º

# easy [225. Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)

## descriptipn

Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).

Implement the `MyStack` class:

- `void push(int x)` Pushes element x to the top of the stack.
- `int pop()` Removes the element on the top of the stack and returns it.
- `int top()` Returns the element on the top of the stack.
- `boolean empty()` Returns `true` if the stack is empty, `false` otherwise.

**Notes:**

- You must use **only** standard operations of a queue, which means that only `push to back`, `peek/pop from front`, `size` and `is empty` operations are valid.
- Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.

**Example 1:**

```
Input
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
```

## solution

```python
class MyStack:

    def __init__(self):
        self.queue1 = deque()
        self.queue2 = deque()

    def push(self, x: int) -> None:
        self.queue2.append(x)
        while self.queue1:
            self.queue2.append(self.queue1.popleft())
        self.queue1, self.queue2 = self.queue2, self.queue1

    def pop(self) -> int:
        return self.queue1.popleft()

    def top(self) -> int:
        return self.queue1[0]

    def empty(self) -> bool:
        return not self.queue1
```



## thought

### ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—

- `queue1`: ä¸»é˜Ÿåˆ—ï¼Œå§‹ç»ˆä¿å­˜å½“å‰æ ˆçš„å…ƒç´ 
- `queue2`: è¾…åŠ©é˜Ÿåˆ—ï¼Œç”¨æ¥ååŠ©å…ƒç´ çš„é‡æ–°æ’åˆ—

### ğŸŒŸ æ“ä½œåŸç†

- **push(x)**ï¼šå…ˆå°† `x` åŠ å…¥ç©ºçš„ `queue2`ï¼Œç„¶åæŠŠ `queue1` ä¸­çš„æ‰€æœ‰å…ƒç´ ä¾æ¬¡å‡ºé˜ŸåŠ åˆ° `queue2`ï¼Œæœ€åäº¤æ¢ä¸¤ä¸ªé˜Ÿåˆ—çš„å¼•ç”¨ã€‚
  - è¿™æ ·ï¼Œ`queue2` çš„é˜Ÿé¦–å°±æ˜¯æ–°åŠ å…¥çš„å…ƒç´ ï¼ˆæ¨¡æ‹Ÿæ ˆé¡¶ï¼‰
- **pop() / top()**ï¼šç›´æ¥è®¿é—® `queue1` çš„é˜Ÿé¦–å³å¯
- **empty()**ï¼šçœ‹ `queue1` æ˜¯å¦ä¸ºç©º

# easy [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

## descriptipn

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

**Input:** s = "()"

**Output:** true

**Example 2:**

**Input:** s = "()[]{}"

**Output:** true

**Example 3:**

**Input:** s = "(]"

**Output:** false

**Example 4:**

**Input:** s = "([])"

**Output:** true

## solution

```python
class Solution:
    def isValid(self, s: str) -> bool:
        notes = {'(':')', '{':'}', '[':']'}
        stack_left = []

        for note in s:
            if note in notes:
                stack_left.append(note)
            else:
                if not stack_left or note != notes[stack_left[-1]]:
                    return False
                stack_left.pop()
        
        if len(stack_left) >0:
            return False
        else:
            return True
```



## thought

Wokeæˆ‘è¿™ä¸ªæœ€æ…¢,æˆ‘çœ‹ä¸€ä¸‹æœ€å¿«çš„æ€ä¹ˆå†™çš„:

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            if c == '(':
                stack.append(')')
            elif c == '{':
                stack.append('}')
            elif c == '[':
                stack.append(']')
            elif not stack or stack.pop() != c:
                return False
        return not stack

```

å¤©æ‰

# easy [1047. Remove All Adjacent Duplicates In String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/)

## descriptipn

You are given a string `s` consisting of lowercase English letters. A **duplicate removal** consists of choosing two **adjacent** and **equal** letters and removing them.

We repeatedly make **duplicate removals** on `s` until we no longer can.

Return *the final string after all such duplicate removals have been made*. It can be proven that the answer is **unique**.

**Example 1:**

```
Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
```

**Example 2:**

```
Input: s = "azxxzy"
Output: "ay"
```

 

## solution

```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        strstack = []

        for c in s:
            if strstack and strstack[-1] == c:
                strstack.pop()
            else:
                strstack.append(c)
        return ''.join(strstack)
```



## thought



# Med [150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

## descriptipn

You are given an array of strings `tokens` that represents an arithmetic expression in a [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).

Evaluate the expression. Return *an integer that represents the value of the expression*.

**Note** that:

- The valid operators are `'+'`, `'-'`, `'*'`, and `'/'`.
- Each operand may be an integer or another expression.
- The division between two integers always **truncates toward zero**.
- There will not be any division by zero.
- The input represents a valid arithmetic expression in a reverse polish notation.
- The answer and all the intermediate calculations can be represented in a **32-bit** integer.

**Example 1:**

```
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
```

**Example 2:**

```
Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
```

**Example 3:**

```
Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

## solution

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        result = 0
        stack = []
        operators = {'+', '-', '*', '/'}

        for token in tokens:
            if token in operators:
                num2 = stack.pop()
                num1 = stack.pop()
                
                if token == '+':
                    result = num1 + num2
                elif token == '-':
                    result = num1 - num2
                elif token == '*':
                    result = num1 * num2
                elif token == '/':
                    result = int(num1 / num2)
                
                stack.append(result)
            else:
                stack.append(int(token))

        return stack[0]
```



## thought



# Hard [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

## descriptipn

You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return *the max sliding window*.

**Example 1:**

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

## solution

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        result = []
        window = deque()

        # éå† numsï¼Œæ¯æ¬¡æ›´æ–°çª—å£å’Œç»“æœ
        for i in range(len(nums)):
            # ç§»é™¤é˜Ÿé¦–ä¸åœ¨çª—å£èŒƒå›´å†…çš„å…ƒç´ ï¼ˆi - kï¼‰
            if window and window[0] <= i - k:
                window.popleft()

            # ä»é˜Ÿå°¾ç§»é™¤æ‰€æœ‰æ¯”å½“å‰ nums[i] å°çš„å…ƒç´ 
            while window and nums[window[-1]] < nums[i]:
                window.pop()

            # å°†å½“å‰ç´¢å¼• i åŠ å…¥é˜Ÿå°¾
            window.append(i)
            
            # å½“ i >= k - 1 æ—¶ï¼ŒæŠŠé˜Ÿé¦–çš„ nums[ç´¢å¼•] åŠ å…¥ result
            if i >= k - 1:
                result.append(nums[window[0]])

        
        return result
```



## thought

å¥½éš¾..

# Med [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

## descriptipn

Given an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.

**Example 1:**

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

## solution

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        c = Counter(nums)
        return [item[0] for item in c.most_common(k)]
```

## thought



