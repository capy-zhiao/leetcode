# 总结

 Python 中常见哈希结构（`dict`、`set`、`Counter`、`defaultdict`）的常用方法和用法总结👇

------

## ✅ `dict`（字典）

字典是键值对的集合，key 必须是不可变类型，value 任意。

### 常用方法：

| 方法                  | 作用              | 示例                    |
| --------------------- | ----------------- | ----------------------- |
| `d[key]`              | 取值              | `d['a']`                |
| `d[key] = value`      | 新增或修改        | `d['a'] = 10`           |
| `d.get(key, default)` | 安全取值          | `d.get('b', 0)`         |
| `d.pop(key)`          | 删除并返回键值    | `d.pop('a')`            |
| `d.keys()`            | 返回所有 key      | `for k in d.keys()`     |
| `d.values()`          | 返回所有 value    | `for v in d.values()`   |
| `d.items()`           | 返回 key-value 对 | `for k, v in d.items()` |
| `key in d`            | 判断 key 是否存在 | `'a' in d`              |
| `len(d)`              | 获取键值对数量    | `len(d)`                |

### 示例：

```python
d = {'a': 1, 'b': 2}
d['c'] = 3
print(d.get('d', 0))  # 输出 0
for k, v in d.items():
    print(k, v)
```

------

## ✅ `set`（集合）

集合是存储**唯一元素**的数据结构，底层也是哈希表。

### 常用方法：

| 方法                           | 作用                   | 示例           |
| ------------------------------ | ---------------------- | -------------- |
| `s.add(x)`                     | 添加元素               | `s.add(3)`     |
| `s.remove(x)`                  | 删除元素，不存在报错   | `s.remove(2)`  |
| `s.discard(x)`                 | 删除元素，不存在不报错 | `s.discard(2)` |
| `s.pop()`                      | 随机删除并返回一个元素 | `s.pop()`      |
| `x in s`                       | 判断元素是否存在       | `3 in s`       |
| `len(s)`                       | 元素数量               | `len(s)`       |
| `s.union(t)` 或 `s             | t`                     | 并集           |
| `s.intersection(t)` 或 `s & t` | 交集                   | `s & t`        |
| `s.difference(t)` 或 `s - t`   | 差集                   | `s - t`        |

### 示例：

```python
s = {1, 2, 3}
s.add(4)
s.discard(2)
print(3 in s)  # True
```

------

## ✅ `collections.Counter`

用于统计元素出现次数（哈希计数器）。

### 常用方法：

| 方法               | 作用                       | 示例                       |
| ------------------ | -------------------------- | -------------------------- |
| `Counter(list)`    | 统计频率                   | `Counter(['a', 'b', 'a'])` |
| `c[key]`           | 获取某元素次数             | `c['a']`                   |
| `c.most_common(n)` | 返回频率最高的 n 个元素    | `c.most_common(2)`         |
| `c.elements()`     | 返回所有元素（按次数重复） | `list(c.elements())`       |

### 示例：

```python
from collections import Counter

c = Counter("banana")
print(c)  # Counter({'a': 3, 'n': 2, 'b': 1})
print(c['a'])  # 3
```

------

## ✅ `collections.defaultdict`

带默认值的字典，避免 `KeyError`。

### 常用方法：

和 `dict` 类似，但你需要传入一个默认类型，如 `int`, `list`, `set`。

### 示例：

```python
from collections import defaultdict

d = defaultdict(int)
d['a'] += 1  # 自动初始化为0再加1

e = defaultdict(list)
e['nums'].append(5)  # 自动初始化为空列表
```

------

## 🧠 建议

| 目标                    | 推荐结构      |
| ----------------------- | ------------- |
| 存键值对                | `dict`        |
| 快速判断是否存在        | `set`         |
| 统计频率                | `Counter`     |
| 键默认值为 list/int/set | `defaultdict` |

------

# easy [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

## decription

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

**Example 1:**

**Input:** s = "anagram", t = "nagaram"

**Output:** true

**Example 2:**

**Input:** s = "rat", t = "car"

**Output:** false

## solution

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)
```

## after

### ✅ 1. 判断字典 A 是否包含字典 B 的所有键和值

意思是：B 的所有键在 A 中也有，且对应的值一样。

#### 示例：

```
python


CopyEdit
a = {'x': 1, 'y': 2, 'z': 3}
b = {'x': 1, 'y': 2}
```

判断：`a` 是否包含 `b`

#### ✅ 方法：

```
python


CopyEdit
def dict_contains(a, b):
    return all(k in a and a[k] == v for k, v in b.items())

print(dict_contains(a, b))  # True
```

------

### ✅ 2. Counter` 的包含判断（频率型字典）

```
python


CopyEdit
from collections import Counter

c1 = Counter("banana")
c2 = Counter("ana")

print(c1 >= c2)  # True，意思是 c1 包含 c2 的所有字符计数
```

# easy [1002. Find Common Characters](https://leetcode.com/problems/find-common-characters/)

## decription

Given a string array `words`, return *an array of all characters that show up in all strings within the* `words` *(including duplicates)*. You may return the answer in **any order**.

**Example 1:**

```
Input: words = ["bella","label","roller"]
Output: ["e","l","l"]
```

**Example 2:**

```
Input: words = ["cool","lock","cook"]
Output: ["c","o"]
```

## solution

```python
class Solution:
    def commonChars(self, words: List[str]) -> List[str]:
        
        result = []
        first = Counter(words[0])
        length = len(words)

        if length == 1:
            for k,v in first.items():
                for i in range(v):
                    result.append(k)
        else:
            for word in words[1:]:
                first &= Counter(word)
            for k,v in first.items():
                for i in range(v):
                    result.append(k)
        
        return result
            
```

## after

写的很杂,主要是如果像cool这样,比如要统计两个o

<img src="assets/image-20250619115908610.png" alt="image-20250619115908610" width="50%;" />

看了一下别人的写法:

```python
from typing import List

class Solution:
    def commonChars(self, words: List[str]) -> List[str]:
        if len(words) == 1:
            return list(words[0])
        
        res = []
        word1 = set(words[0])
        for char in word1:
            frequency = min([word.count(char) for word in words])
            res += [char] * frequency
        return res
```

# easy [349. Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)

## decription

Given two integer arrays `nums1` and `nums2`, return *an array of their intersection*. Each element in the result must be **unique** and you may return the result in **any order**.

**Example 1:**

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
```

**Example 2:**

```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
```

## solution

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        result = []
        common = Counter(nums1)
        for k in common.keys():
            if int(k) in nums2:
                result.append(k)
        return result
```

## after

7ms

<img src="assets/image-20250619123928964.png" alt="image-20250619123928964" width="50%;" />

看了下别人的写法:

class Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:        return list(set(nums1).intersection(set(nums2)))        

# easy [202. Happy Number](https://leetcode.com/problems/happy-number/)

## decription

Write an algorithm to determine if a number `n` is happy.

A **happy number** is a number defined by the following process:

- Starting with any positive integer, replace the number by the sum of the squares of its digits.
- Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.
- Those numbers for which this process **ends in 1** are happy.

Return `true` *if* `n` *is a happy number, and* `false` *if not*.

**Example 1:**

```
Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**Example 2:**

```
Input: n = 2
Output: false
```

## solution

```python
class Solution:
    def sum_squares(self, n: int):
        result = 0
        while n:
            q, v = divmod(n, 10)
            result += v ** 2
            n = q
        return result

    def isHappy(self, n: int) -> bool:
        seen = set()
        while True:
            n = self.sum_squares(n)
            if n == 1:
                return True
            if n in seen:
                return False
            seen.add(n)
```

## after

divmod(126,10) = 12, 6

 就是判断有没有循环

<img src="assets/image-20250623134233407.png" alt="image-20250623134233407" width="40%;" />

# easy [1. Two Sum](https://leetcode.com/problems/two-sum/)

## decription

Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*.

You may assume that each input would have ***exactly\* one solution**, and you may not use the *same* element twice.

You can return the answer in any order.

**Example 1:**

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**

```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Example 3:**

```
Input: nums = [3,3], target = 6
Output: [0,1]
```

## solution

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        length = len(nums)
        # 5
        #0, 1, 2, 3
        for i in range(length-1):
            #i = 3, (4, 5), j = 4
            for j in range(i+1, length):
                tmp = nums[i]+nums[j]
                if tmp == target:
                    return [i,j]
```

## after

  耗时有点大,

<img src="assets/image-20250623135012664.png" alt="image-20250623135012664" width="40%;" />

看了最优解:

for index, num in enumerate(nums): 遍历整个数组，拿到当前的索引和数值。

Input: nums = [3,2,4], target = 6 Output: [1,2]

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        num_map = {}  # Hash table to store number and its index
        for i, num in enumerate(nums):
            complement = target - num  # Find the complement
            if complement in num_map:
                return [num_map[complement], i]  # Return indices of complement and current number
            num_map[num] = i  # Store the number with its index
```

| 循环次数 | 当前索引 `i` | 当前值 `num` | 目标补数 `complement = target - num` | 当前哈希表 `num_map` | 补数是否已在表中？ | 操作          | 是否返回结果 |
| -------- | ------------ | ------------ | ------------------------------------ | -------------------- | ------------------ | ------------- | ------------ |
| 1        | 0            | 3            | 3                                    | `{}`                 | ❌ 否               | 存入 `3:0`    | 否           |
| 2        | 1            | 2            | 4                                    | `{3: 0}`             | ❌ 否               | 存入 `2:1`    | 否           |
| 3        | 2            | 4            | 2                                    | `{3: 0, 2: 1}`       | ✅ 是 (`2` 在表中)  | 返回 `[1, 2]` | ✅ 是         |

# Med [454. 4Sum II](https://leetcode.com/problems/4sum-ii/)

## decription

Given four integer arrays `nums1`, `nums2`, `nums3`, and `nums4` all of length `n`, return the number of tuples `(i, j, k, l)` such that:

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

**Example 1:**

```
Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
Output: 2
Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

**Example 2:**

```
Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
Output: 1
```

## solution

```python
class Solution:
    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        length = len(nums1)

        sum_1 = defaultdict(int)
        count = 0

        for i in range(length):
            for j in range(length):
                sum_1[nums1[i]+nums2[j]] += 1

        for k in range(len(nums3)):
            for l in range(len(nums4)):
                sum_2 = nums3[k] + nums4[l]
                count += sum_1[-sum_2] 

        return count
```

## after

count += sum_1[-t]
如果 -t 不在 sum_1 里，？
如果用的是 普通字典 dict，会报错：KeyError。

如果用的是 defaultdict(int)，就不会报错，会自动返回默认值 0，所以是安全的.

<img src="assets/image-20250623141348767.png" alt="image-20250623141348767" width="40%;" />

# easy [383. Ransom Note](https://leetcode.com/problems/ransom-note/)

## decription

Given two strings `ransomNote` and `magazine`, return `true` *if* `ransomNote` *can be constructed by using the letters from* `magazine` *and* `false` *otherwise*.

Each letter in `magazine` can only be used once in `ransomNote`.

**Example 1:**

```
Input: ransomNote = "a", magazine = "b"
Output: false
```

**Example 2:**

```
Input: ransomNote = "aa", magazine = "ab"
Output: false
```

**Example 3:**

```
Input: ransomNote = "aa", magazine = "aab"
Output: true
```

## solution

```python

```

## after

  



# Med [15. 3Sum](https://leetcode.com/problems/3sum/)

## decription

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```

**Example 2:**

```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```

**Example 3:**

```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

## solution

```python

```

## after

  

# Med [18. 4Sum](https://leetcode.com/problems/4sum/)

## decription

Given an array `nums` of `n` integers, return *an array of all the **unique** quadruplets* `[nums[a], nums[b], nums[c], nums[d]]` such that:

- `0 <= a, b, c, d < n`
- `a`, `b`, `c`, and `d` are **distinct**.
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

You may return the answer in **any order**.

**Example 1:**

```
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**Example 2:**

```
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
```

## solution

```python

```

## after

  
