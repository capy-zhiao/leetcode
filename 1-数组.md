# [easy 704. Binary Search](https://leetcode.com/problems/binary-search/)

## description

Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.

You must write an algorithm with `O(log n)` runtime complexity.

 **Example 1:**

```
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
```

**Example 2:**

```
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
```

**Constraints:**

- `1 <= nums.length <= 104`
- `-104 < nums[i], target < 104`
- All the integers in `nums` are **unique**.
- `nums` is sorted in ascending order.

## My solution

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        for i in range(len(nums)):
            if target == nums[i]:
                return i
        return -1
```

# [easy 27. Remove Element](https://leetcode.com/problems/remove-element/)

## description

Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return *the number of elements in* `nums` *which are not equal to* `val`.

Consider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:

- Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.
- Return `k`.

**Custom Judge:**

The judge will test your solution with the following code:

```
int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

If all assertions pass, then your solution will be **accepted**.

**Example 1:**

```
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

**Example 2:**

```
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

## my solution

```python
class Solution:
    def shift_function(self, nums, index, fill):
        for i in range(index, len(nums) - 1):
            nums[i] = nums[i+1]
        nums[-1] = fill
            
    def removeElement(self, nums: List[int], val: int) -> int:
        count = 0

        fill = -1
        while True:
            try:
                i = nums.index(val)
                self.shift_function(nums, i, fill)
                count += 1
            except:
                return (len(nums) - count)
```

## after

效率0m s

主要就是,记得新定义函数要加一个self,然后引用这个函数也要加self.xxx

差不多就是一只true找到下标,然后再把后面的元素一个一个移动到前面去

# [easy 977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)

## description

Given an integer array `nums` sorted in **non-decreasing** order, return *an array of **the squares of each number** sorted in non-decreasing order*.

**Example 1:**

```
Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Explanation: After squaring, the array becomes [16,1,0,9,100].
After sorting, it becomes [0,1,9,16,100].
```

**Example 2:**

```
Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]
```

## mysolution

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            nums[i] = nums[i]*nums[i]
        nums.sort()
        return nums
```

## after

但是这个是7m s
我看了一下更好的解决方法是这个

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        return sorted(x*x for x in nums)
```

但是这个也是4m s

找了一个0m s的:

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        sq=[]
        for i in nums:
            s=i*i
            sq.append(s)
        return sorted(sq)
```

# medium [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)

## description

Given an array of positive integers `nums` and a positive integer `target`, return *the **minimal length** of a* *subarray* *whose sum is greater than or equal to* `target`. If there is no such subarray, return `0` instead.

**Example 1:**

```
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
```

**Example 2:**

```
Input: target = 4, nums = [1,4,4]
Output: 1
```

**Example 3:**

```
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
```

## solution

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        windows = deque()
        wsum = 0
        k = 1000000000000
        for num in nums:
            windows.append(num)
            wsum += num
            while wsum >= target:
                k = min(k, len(windows))
                wsum -= windows.popleft()
        if k == 1000000000000: return 0
        return k
```

## After

学了一个滑动窗口

可以根据这个测试log看看:

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        windows = deque()
        wsum = 0
        k = 1000000000000
        for num in nums:
            print("1------:"+str(num))
            windows.append(num)
            print("windows:",windows)
            wsum += num
            print("wsum:",wsum)
            while wsum >= target:
                k = min(k, len(windows))
                print("while ---- windows:",windows)
                print("while ---- wsum:",wsum)
                print("while ---- k:",k)
                wsum -= windows.popleft()
                print("while ---- wsumpopleft:",wsum)
        if k == 1000000000000: return 0
        return k
```

Log":

```
1------:2
windows: deque([2])
wsum: 2
1------:3
windows: deque([2, 3])
wsum: 5
1------:1
windows: deque([2, 3, 1])
wsum: 6
1------:2
windows: deque([2, 3, 1, 2])
wsum: 8
while ---- windows: deque([2, 3, 1, 2])
while ---- wsum: 8
while ---- k: 4
while ---- wsumpopleft: 6
1------:4
windows: deque([3, 1, 2, 4])
wsum: 10
while ---- windows: deque([3, 1, 2, 4])
while ---- wsum: 10
while ---- k: 4
while ---- wsumpopleft: 7
while ---- windows: deque([1, 2, 4])
while ---- wsum: 7
while ---- k: 3
while ---- wsumpopleft: 6
1------:3
windows: deque([2, 4, 3])
wsum: 9
while ---- windows: deque([2, 4, 3])
while ---- wsum: 9
while ---- k: 3
while ---- wsumpopleft: 7
while ---- windows: deque([4, 3])
while ---- wsum: 7
while ---- k: 2
while ---- wsumpopleft: 3
```

# medium [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)

## description

Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order.

**Example 1:**

![img](assets/spiraln.jpg)

```
Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]
```

**Example 2:**

```
Input: n = 1
Output: [[1]]
```

**Constraints:**

- `1 <= n <= 20`

| 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- |
| 12   | 13   | 14   | 5    |
| 11   | 16   | 15   | 6    |
| 10   | 9    | 8    | 7    |



## solution

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        result = [[0]*n for i in range(n)]
        top = 0
        bottom = n-1
        left = 0
        right = n-1
        num = 1
        while top <= bottom and left <= right:

            for i in range(left, right+1):
                result[left][i] = num
                num += 1
            top+=1

            for i in range(top, bottom+1):
                result[i][right] = num
                num += 1
            right -= 1

            for i in range(right, left-1, -1):
                result[bottom][i] = num
                num+=1
            bottom -= 1

            for i in range(bottom, top-1, -1):
                result[i][left] = num
                num+=1
            left += 1
        return result
```



## after

嗯,就是,挨着挨着判断,学到了一个ran ge(大的,小的,-1)